相談メモ (2022.02.17)


下記の査読者Aからの照会事項について、

  ３箇月後（2022 年 02 月 21 日）

までに、下記担当編集委員あてにご回答いただきたいと存じます。

論文原稿を改訂した場合には改訂版最新原稿（変更箇所を回答書に明記）を、改訂のない場合には投稿時の原稿をあわせてお送り願います。
回答書をプレインテキストまたは PDF 形式で、また論文原稿を PDF 形式でお送りください。

[照会事項]
読者にとって有意義な研究成果を含む内容にするために，以下の点に対応してください．

1. Coq上で形式化する上での困難さや工夫があれば，具体的に記述してください．現在のところ，工夫として 5
節に「彩色関数を用いたこと」が記述されていますが，それほど大きなものではなく，大会での発表においても複数の方から指摘があったように，問題設定からほぼ自明な考え方であり，それほど大きな工夫とは言えません．また，Coq上で形式化することの困難さについても詳しい考察があれば，それにどう対処したかなど興味深い考察ができるかもしれません．

2. Coq上で形式化することでの恩恵があれば，具体的に記述してください．補題3.11の証明において81通りの場合分けを1行で記述できるという点や，5節で言及されているようにSSReflect特有のreflection機能を通じて証明が簡潔に記述できたという点もあるでしょう．また，それらの点の他にも説得力のある例が具体的な文脈とともに記述されていれば，今後の類似研究を行う読者にも有益になるものと期待されます．
--------------------------------------------

1.「Coq上で形式化する上での困難さや工夫」
- やってみて出会った困難とそれをどう工夫して乗り越えたか
- cpos 関数化

[三角形の位置を自由に動かせるようにパラメータを追加した]
素朴に考えると，最終的な定理を記述するために必要なのは段数の情報だけであることから
n段の逆三角形の端点の位置を(0,0),(n,0),(0,n)と固定して WellColoredTriangle' n のように書けばよい．
そのために Triangle' cpos n を cpos 0 n = mix (cpos 0 0) (cpos n 0) と定義して
WellColoredTriangle' n を forall cpos, next cpos -> Triangle' cpos n により定義することが考えられる．
しかし，この定義だと十分条件において帰納法が回らない問題が発生した．
なぜなら，段数3^{k+1}の三角形が調和彩色三角形であることを示すために，
その中の6つの段数3^kの部分三角形が調和彩色三角形であることを帰納法の仮定より導く必要があるからである．
これに対処するための工夫として，逆三角形の位置を自由に動かせるように端点を(x,y),(x+n,y),(x,y+n)として
Triangle は x y をパラメータとして追加，WellColoredTriangle は x をパラメータとして追加した．




[座標の表し方を相対座標ではなく絶対座標にした]
関数 colorYB，colorYBBY といった与えられた自然数の偶奇で最上段の塗り方を与える関数の定義の選択として，
逆三角形の左上の端点(x,y)としたときに
	(a) マス(x+i,y)の色を i に関する関数として定義する，もしくは
	(b) 塗る(z,y)の色は基準(x,y)から何マス動いたか z-x の偶奇で与える．
といったものが考えられる．
(b) の方法では，x の偶奇によらず関数 colorYB，colorYBBY の色ぬりは一様に定義できる（必ず黄色から塗り始められる）．
そのため，形式化を進めていく中で x の偶奇について場合分けする必要がなくなり，
証明を簡潔に書くことができると考え，最初は (b) を採用していた．
しかし，(b) を採用してしまうと相対的に座標を表しているため，
変数の数が増えてしまい座標がやや複雑な式になってしまった．
そこで，(a) に切り替えることで変数の数を最小限に抑えることができ，式の形も簡潔に記述することができるようになった．
また，(b) の方法では座標を表す際に，減法（引き算）を用いる必要があるという点も式を複雑にしていた要因である．
この問題点も同時に解決することができたので (a) を採用する意味があったと考えられる．
結果として (a) を採用すると，偶奇に関して場合分けをする必要がでてくるが，
タクティック rewrite を適用しやすくなり，(b) よりも証明をより短く書くことができた．

--------------------------------------------------
最初に何をしたら，(colorYBBYを(b)で定義した)
どのような問題が発生し，(？？)
どうやって解決して，((a)に変更した)
それによりどのように良くなったか (???)
一般的にいいたい 
--------------------------------------------------

上記のことを一般化すると，以下の [1]，[2] がいえる：

[1]
座標で位置を "相対座標" で表すと変数が増えてしまうため Coq 上で証明しにくくなってしまう．
なぜなら，相対座標の方が絶対座標よりも変数の数が多くなってしまうからである．
したがって，Coq 上で座標で位置を表す際には "絶対座標" で表した方が証明をしやすくなる．

[2]
今回のように偶奇による場合分けを減らすために相対的に座標を表すと証明が簡潔になると考えたがかえって証明が大変になってしまった．
このことから，紙面上での証明がしやすいからといって，同じように証明しても Coq 上で証明がしやすいとは限らないことが言える．
一方で絶対座標に変更したときのように，紙面上での証明はしにくいが，Coq 上の証明がしやすい証明があることも分かった．
これらの証明のしやすさの違いは "機械的な" 証明であるかという点だと考えられる．
関数が返す値は関数に与えた変数が関数に定義された条件を満たすことを示すことで定まる．
このとき関数に定義されている条件は ( Prop 型は関数の条件として定義できないため ) bool 型である場合が多く，
 SSReflect の強みであるコアーションやタクティック rewrite による等式変形を活用することで簡潔に示すことができる．
等式変形で進めていくような "機械的な" 証明はやはり SSReflect の恩恵を得られるので非常に相性がよい．

以上のことを踏まえると，紙面上と Coq 上では証明方法によっては証明のしやすさが異なる場合があるので，
証明の形態によって適切な証明の方針を考えたり，
紙面上の証明を Coq で形式化する際には機械的に証明をできるように関数等の定義を考えた方がよい．

[恩恵]
数学の証明は正しいかどうかのみに目がいきがちだが，
Coqは正しいことは保証されるので，その先を気にすることができる．
証明の効率のよさ (プログラミング的な見方) みたいなものを話しあうことができる．
その観点で議論ができる．

SSReflect をこのように使うと上手く書けたとかなんとか

