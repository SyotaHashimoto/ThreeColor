相談メモ (2022.02.17)


下記の査読者Aからの照会事項について、

  ３箇月後（2022 年 02 月 21 日）

までに、下記担当編集委員あてにご回答いただきたいと存じます。

論文原稿を改訂した場合には改訂版最新原稿（変更箇所を回答書に明記）を、改訂のない場合には投稿時の原稿をあわせてお送り願います。
回答書をプレインテキストまたは PDF 形式で、また論文原稿を PDF 形式でお送りください。

[照会事項]
読者にとって有意義な研究成果を含む内容にするために，以下の点に対応してください．

1. Coq上で形式化する上での困難さや工夫があれば，具体的に記述してください．現在のところ，工夫として 5
節に「彩色関数を用いたこと」が記述されていますが，それほど大きなものではなく，大会での発表においても複数の方から指摘があったように，問題設定からほぼ自明な考え方であり，それほど大きな工夫とは言えません．また，Coq上で形式化することの困難さについても詳しい考察があれば，それにどう対処したかなど興味深い考察ができるかもしれません．

2. Coq上で形式化することでの恩恵があれば，具体的に記述してください．補題3.11の証明において81通りの場合分けを1行で記述できるという点や，5節で言及されているようにSSReflect特有のreflection機能を通じて証明が簡潔に記述できたという点もあるでしょう．また，それらの点の他にも説得力のある例が具体的な文脈とともに記述されていれば，今後の類似研究を行う読者にも有益になるものと期待されます．
--------------------------------------------

1.「Coq上で形式化する上での困難さや工夫」
- やってみて出会った困難とそれをどう工夫して乗り越えたか
- cpos 関数化

[三角形の位置を自由に動かせるようにパラメータを追加した]
素朴に考えると，最終的な定理を記述するために必要なのは段数の情報だけであることから
n段の逆三角形の端点の位置を(0,0),(n,0),(0,n)と固定して WellColoredTriangle' n のように書けばよい．
そのために Triangle' cpos n を cpos 0 n = mix (cpos 0 0) (cpos n 0) と定義して
WellColoredTriangle' n を forall cpos, next cpos -> Triangle' cpos n により定義することが考えられる．
しかし，この定義だと十分条件において帰納法が回らない問題が発生した．
なぜなら，段数3^{k+1}の三角形が調和彩色三角形であることを示すために，
その中の6つの段数3^kの部分三角形が調和彩色三角形であることを帰納法の仮定より導く必要があるからである．
これに対処するための工夫として，逆三角形の位置を自由に動かせるように端点を(x,y),(x+n,y),(x,y+n)として
Triangle は x y をパラメータとして追加，WellColoredTriangle は x をパラメータとして追加した．

--------------------------------------------------
最初に何をしたら，(colorYBBYを(b)で定義した)
どのような問題が発生し，(？？)
どうやって解決して，((a)に変更した)
それによりどのように良くなったか (???)
一般的にいいたい 
--------------------------------------------------

----- ここから追記事項 (2022.2.20) -----

[座標の表し方を相対座標ではなく絶対座標にした]
関数 colorYB，colorYBBY といった与えられた自然数の偶奇で最上段の塗り方を与える関数の定義の選択として，
逆三角形の左上の端点(x,y)としたときに
	(a) マス(x+i,y)の色を i に関する関数として定義する，もしくは
	(b) 塗る(z,y)の色は基準(x,y)から何マス動いたか z-x の偶奇で与える．
といったものが考えられる．
(b) の方法では，x の偶奇によらず関数 colorYB，colorYBBY の色ぬりは一様に定義できる（必ず黄色から塗り始められる）．
そのため，形式化を進めていく中で x の偶奇について場合分けする必要がなくなり，
証明を簡潔に書くことができると考え，最初は (b) を採用していた．
しかし，(b) を採用してしまうと相対的に座標を表しているため，
変数の数が増えてしまい座標がやや複雑な式になってしまった．
そこで，(a) に切り替えることで変数の数を最小限に抑えることができ，式の形も簡潔に記述することができるようになった．
また，(b) の方法では座標を表す際に，減法（引き算）を用いる必要があるという点も式を複雑にしていた要因である．
この問題点も同時に解決することができたので (a) を採用する意味があったと考えられる．
結果として (a) を採用すると，偶奇に関して場合分けをする必要がでてくるが，
タクティック rewrite を適用しやすくなり，(b) よりも証明をより短く書くことができた．

上記のことを一般化すると，以下の [1]，[2] がいえる：

[1]
座標で位置を "相対座標" で表すと Coq 上で証明しにくくなってしまう．
なぜなら，相対座標の方が絶対座標よりも変数や演算の数が多くなってしまうからである．
したがって，Coq 上で座標で位置を表す際には "絶対座標" で表した方が証明をしやすくなることがある．

[2]
今回のように偶奇による場合分けを減らすために相対的に座標を表すと証明が簡潔になると考えたがかえって証明が大変になってしまった．
このことから，紙面上での証明がしやすいからといって，同じように証明しても Coq 上で証明がしやすいとは限らないことが言える．
一方で絶対座標に変更したときのように，紙面上での証明はしにくいが，Coq 上の証明がしやすい証明があることも分かった．
これらの証明のしやすさの違いは "機械的な" 証明であるかという点だと考えられる．
関数が返す値は関数に与えた変数が関数に定義された条件を満たすことを示すことで定まる．
このとき関数に定義されている条件は ( Prop 型は関数の条件として定義できないため ) bool 型である場合が多く，
 SSReflect の強みであるコアーションやタクティック rewrite による等式変形を活用することで比較的簡潔に示すことができる．
そのため，等式変形で進めていくような "機械的な" 証明はやはり SSReflect の恩恵を得られるので非常に相性がよい．

以上のことをまとめると，紙面上と Coq 上では証明方法によっては証明のしやすさが異なる場合があるので，
証明の形態によって適切な証明の方針を考えたり，
紙面上の証明を Coq で形式化する際には機械的に証明をできるように関数等の定義を与えた方がよい．

-- memo0201.txt より -----------------------------
- マスの色塗り方法を関数 Cpos を用いて形式化した．論理式 Cpos'(x,y,col) とそれが満たす公理(各マスには一色だけ塗られているなど)を用いて形式化して証明を与えること自体は可能だが，論理式の操作が必要となり，非本質的で回りくどい議論によって証明の本質が見えにくくなる．関数を用いた形式化により等式操作が可能となり，ssreflect の恩恵を受けることができた．
--------------------------------------------------

[恩恵]
- 数学の証明は正しいかどうかのみに目がいきがちだが，
Coqは正しいことは保証されるので，その先を気にすることができる．
証明の効率のよさ (プログラミング的な見方) みたいなものを話しあうことができる．
その観点で議論ができる．

- Coq 上の証明の方が紙面上の証明と比べて，人の機械的なミスに恐れずに証明する主張の順番をある程度変更ができる（タクティカル first や last を用いる）．
紙面上の証明の場合は証明する順番を変えると，証明しなければならない主張の証明を忘れてしまう可能性があるが，Coq 上の証明では証明の順番を変えても Coq がサブゴールとして表示するため証明忘れを防止できる．
また，タクティック suff を用いることで「仮に◯◯が成立すると...」のような記述を人の機械的なミスに恐れずに書くことができるため，
証明の各場面における証明したい主張のみに集中することができる．

- 以下のようにタクティカルを用いるとタクティックの使用回数を減らすことができるため証明を短くすることができた．
-- 場合分けにおいて同じことの機械的な操作の繰り返しで処理できる部分はタクティカル [ | | ] で短く記述することができた．また，場合分けをおこない最初の示すべき主張が比較的簡単に示すことができるときには，タクティカル first を用いることで場合分けと同時にサブゴールを1つ処理することができる．

-- タクティック have を用いて等式変形をする際には，タクティック have にタクティカル -> を合わせて用いると，have の内容を示した後に自動的に示した内容で等式を変形できる．さらに，等式変形後のサブゴールが成立することが明らかな場合はタクティカル // も合わせて用いることでサブゴールを1つ処理することができる．また，タクティカル // はタクティック rewrite でも同様に用いることができる．

-- memo0201.txt より -----------------------------
- Section を用いることで証明を構造化した．
これにより仮定を共有する複数の主張をグループ化したり，ある定理を示すためだけに用いられる補題はセクションの中で局所化することで各主張の論理的な繋がりが明確になった（TCTP_nec_even とか TCTP_nec_longodd など)．
--------------------------------------------------

-- 照会事項 より -----------------------------
- 補題 3.11 の証明において81通りの場合分けを1行で記述できる．
- 5 節で言及されているように SSReflect 特有の reflection 機能を通じて証明が簡潔に記述できた．
--------------------------------------------------
