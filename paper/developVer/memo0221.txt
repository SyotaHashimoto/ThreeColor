相談メモ (2022.02.21)

下記の査読者Aからの照会事項について、

  ３箇月後（2022 年 02 月 21 日）

までに、下記担当編集委員あてにご回答いただきたいと存じます。

論文原稿を改訂した場合には改訂版最新原稿（変更箇所を回答書に明記）を、改訂のない場合には投稿時の原稿をあわせてお送り願います。
回答書をプレインテキストまたは PDF 形式で、また論文原稿を PDF 形式でお送りください。

[照会事項]
読者にとって有意義な研究成果を含む内容にするために，以下の点に対応してください．

1. Coq上で形式化する上での困難さや工夫があれば，具体的に記述してください．現在のところ，工夫として 5
節に「彩色関数を用いたこと」が記述されていますが，それほど大きなものではなく，大会での発表においても複数の方から指摘があったように，
問題設定からほぼ自明な考え方であり，それほど大きな工夫とは言えません．また，Coq上で形式化することの困難さについても詳しい考察があれば，それにどう対処したかなど興味深い考察ができるかもしれません．

2. Coq上で形式化することでの恩恵があれば，具体的に記述してください．補題3.11の証明において81通りの場合分けを1行で記述できるという点や，5節で言及されているようにSSReflect特有のreflection機能を通じて証明が簡潔に記述できたという点もあるでしょう．また，それらの点の他にも説得力のある例が具体的な文脈とともに記述されていれば，今後の類似研究を行う読者にも有益になるものと期待されます．
------------------------------------------------------------------------------------------------------------------------------------


松田様，

投稿論文「Coq による三角形三色問題の証明」著者の橋本です．
2名の査読者の方に細部までよく読んでいただき，有益なご指摘とアドバイスをいただけたことに感謝いたします．

お尋ねの照会事項について下記の通りお答えいたします．

なお，いただいたコメントを基にソースコードを整理して改訂しました．
最新版のコードは
https://github.com/SyotaHashimoto/ThreeColor/proof/threecolor.v
に置きました．以下の回答はなるべく投稿版のソースコードの内容 (Coqによる三角形三色問題の証明.v) に
準拠する形で書いていますが，一部どうしても最新版の内容を参照する必要がある場合はその旨を明記しています．


どうぞよろしくお願い申し上げます．

橋本翔太・木村大輔



============================================

最初の照会事項「1. Coq上で形式化する上での困難さや工夫があれば，具体的に記述してください．」
についてお答えいたします．

形式化にあたって大きな困難はありませんでしたが，素朴な発想だとところどころ詰まった場所がありましたので，
いくつかの工夫をして修正しながら証明を完成させました．
工夫についてまとめると以下の 3点が挙げられます．
(以下，逆三角形の左上のマスのことを，その逆三角形の「基準マス」とよび，その位置を「基準座標」と呼びます)

(1a) 述語 WellColoredTriangle と Triangle に基準座標に関するパラメータを追加しました．
(1b) 最上段の色塗り関数 (colorYB や colorYBBY) を黄色と青の対称性を利用して簡略化しました (最新版の内容)
(1c) 逆三角形の彩色の表現に関して彩色述語とそれに関する公理を用いる方針から彩色関数に変更しました (論文中で述べた内容)
最後の (1c) は既に議論されていますので，(1a)と(1b)について詳しく述べます．

(1a) について．
最終的な定理 (定理2.5) は n段の逆三角形の端点の座標が(0,0),(n,0),(0,n)であることから，
素朴に形式化しようとすると以下のような段数 n に関する論理式が考えられます：
 foralln:nat , n>0 -> (existsk:nat,n=3^k) <-> (WellColoredTriangle' n). 
ただし，WellColoredTriangle' の定義は以下の通りです：
 Definition TriangleF' cpos n : bool := (cpos 0 n) = mix (cpos 0 0) (cpos n 0). 
 Definition WellColoredTriangle' n := forall cpos: nat->nat->Color, F_mix cpos -> Triangle' cpos n. 
しかし，この定義だと十分条件において帰納法が回らない問題が発生しました．
理由としては段数 3^{k+1} の逆三角形が調和彩色三角形であることを示すために，
その中の6つの段数 3^k の部分逆三角形が調和彩色三角形であることを帰納法の仮定より導く必要があるからです．
この問題に対処するための工夫として，逆三角形の位置を自由に動かせるように端点の座標を(x,y),(x+n,y),(x,y+n)として
TriangleF には x y をパラメータとして追加，WellColoredTriangleF には x をパラメータとして追加することで解決しました．

(1b) について．
最上段の色塗り関数 colorYB や colorYBBY による色塗りは黄色と青を逆転させても議論の本質は変わらず，対称的です
(次の論文の改訂で第2節の説明にこの点を書き加える予定です)．
最新版のコードではこの性質を利用して関数の定義を大幅に簡略化しました．
関数 colorYB (最新版では coloringYB と変更しました) の定義は
 Definition coloringYB n x := if (x <= n) && ~~ odd x then yel else blu.
で与えています．この定義は基準座標のx座標が偶数なら「黄青黄…」と塗り，奇数なら「青黄青…」と塗ることを想定しています．
前述の(1a)より逆三角形の基準座標は(0,0)とは限らないため，任意の場所を基準座標に取っても議論が成立することが
必要になります．投稿版では colorYB を黄色から必ず開始すると固定していたため，対象座標の基準座標からの相対位置を得るために
x座標の差分を計算し，その差分の偶奇で場合分けをしていました．一般に自然数の差分の計算は複雑化の要因となりますが，
この点が解消されたおかげで簡略化に成功しました．


2つ目の照会事項「2. Coq上で形式化することでの恩恵があれば，具体的に記述してください．」
についてお答えいたします．
既に述べた81通りの場合分けの処理や SSReflect の reflection 機能以外の恩恵に関しては以下の点が挙げられます．

(2a) 通常の数学の証明は定理が正しいかどうかに主眼が置かれますが，Coq では正しいことは保証されるのでその先を気にすることができます．
定義や補題が簡潔に記述できているか，タクティクを有効に使って効率よく証明を行っているかなど，一種のプログラムとしての観点で
議論する環境を与えてくれます．今回の内容では査読者の方々にコードのレビューをしていただき，修正案も提示していただけたおかげで
SSReflect を効率的に使う方法を学ぶことができました．その成果が最新版のコードです．

(2b) 紙の上の証明では場合分けの単純な場合を「明らか」として済ませたり，暗算できるような自明な等式であればわざわざ書くことなしに用いてゴールを書き換えるなどの
一足飛びをすることは普通ですが，Coq で証明を行う場合はこのような小さく飛ばすステップも明示的に記述する必要があります．
SSReflect が提供するタクティクを用いることで複数の細かい操作を一度に行うことができ，厳密でいながら紙の証明と近い感覚で議論を進めることができます．
今回の最新版への改訂ではこの機能を積極的に用いることで効率的なコードへと修正できました．
いくつか具体例を挙げます．
(2b-1) いくつかのサブゴールに分割し，その後のいくつかの処理も同時にするときはタクティカル [ | ] を使って短く記述しました．典型的な例としては以下があります：
Let longodd_red_both_sides :
  (forall i, i <= n - (3 ^ k).*2 -> colfun (x + i) (3 ^ k) = red) /\
  (forall i, 3 ^ k <= i <= n - 3 ^ k -> colfun (x + i) (3 ^ k) = red).
Proof.
  split=> [i i_range_right|i /andP[i_range_left i_range_right]];
...
Qed.
これは「ゴールを split で2つのサブゴールに分割し，1つ目のサブゴールに move=> i i_range_right を適用する，
2つ目のサブゴールには move=> i. move=> /andP [i_range_left i_range_right]. を適用する」を同時に行っています．
紙の上の証明でもこれくらいの処理を明示せずにやると思われますが，この処理を厳密性を確保しつつ同様の感覚で簡潔に書くことができるようになりました．

(2b-2) タクティック have とタクティカル -> (もしくは <-) の組合せでhave の内容を示した後に自動的に示した内容で等式を変形する機能を積極的に利用しました．
特に have の内容が明らかな場合はタクティカル // を利用することで瞬時に処理することができて重宝しました．
使用例としては以下があります：
Lemma TCTP_nec_longodd x n k :
  (3 ^ k).*2.+1 <= n < 3 ^ k.+1 -> ~ WellColoredTriangle x n.
Proof.
  ...
  have -> : colfun x n = red; first by exact: (longodd_bottom _ k).
  have -> : colfun x 0 = blu by rewrite -(addn0 x) -topcolor// BYB_blu_left.
  have ->// : colfun (x + n) 0 = blu.
  ...
Qed.
1つ目の have は主張 colfun x n = red を導入した直後に証明し，ゴールをこの等式を用いて変形しています．
2つ目も同様に行っています．さらに3つ目は // により自明な主張の証明を瞬時に済ませています．
これくらい簡潔に記述できることは，完成後の証明の短縮化につながることはもちろんのこと，
多数の細かく(当たり前に見える)処理に追われることに対するユーザのストレス軽減にも繋がることを実感しました．






